<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>The Gift of Gab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0A0A0F"/>
  <meta name="description" content="The Gift of Gab â€” a retroâ€‘futuristic AI chat with a technical blog hub." />
  <style>
    /* =========================================================
       THE GIFT OF GAB â€” Singleâ€‘file SPA (HTML+CSS+JS)
       Retroâ€‘futuristic, dark theme (black + pink)
       Version: overlay + spinner; no auto-fullscreen on input/click
       ========================================================= */

    :root{
      --bg:#0a0a0f;
      --bg-2:#0e0e16;
      --panel:#12121c;
      --panel-2:#171726;
      --text:#e9e9f2;
      --muted:#a5a7bf;
      --line:#1e1e2e;
      --pink:#ff2e88;
      --pink-2:#ff86c3;
      --glow: 0 0 .5rem var(--pink), 0 0 1.25rem color-mix(in oklab, var(--pink) 70%, white 0%), 0 0 2.5rem color-mix(in oklab, var(--pink) 35%, black 65%);
      --radius:16px;
      --pad: clamp(14px, 1.6vw, 22px);
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--font);
      color:var(--text);
      background:
        radial-gradient(1200px 520px at 50% -160px, rgba(255,46,136,.12), transparent 75%),
        linear-gradient(180deg, #090914 0%, #050509 45%, #030306 75%, #020203 100%);
      background-color:#020203;
      background-repeat:no-repeat, no-repeat;
      background-size:130% 70%, 100% 100%;
      background-position:center top, center top;
      line-height:1.45;
      overflow-x:hidden;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Subtle scanlines for retro vibe (disabled for reduced motion) */
    body::before{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      background-image: linear-gradient(rgba(255,255,255,.03),rgba(255,255,255,0) 2px);
      background-size:100% 3px; mix-blend-mode:overlay; opacity:.25;
    }
    @media (prefers-reduced-motion: reduce){
      body::before{display:none}
      *{animation: none !important; transition: none !important}
    }

    .container{width:min(1000px, 92vw); margin-inline:auto}

    .nav-actions{display:flex; gap:.5rem; align-items:center}
    .token-control{
      display:flex; align-items:center; gap:.4rem;
      font-size:12px; color:var(--muted); font-weight:600;
    }
    .token-control input{
      width:58px; padding:.4rem .5rem;
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
      border:1px solid color-mix(in oklab, var(--pink) 35%, #ffffff00 65%);
      border-radius:999px; color:var(--text);
      font-size:12px; font-family:var(--mono);
      text-align:center; outline:none;
      transition: border-color .15s ease, box-shadow .15s ease;
      -moz-appearance:textfield; appearance:textfield;
    }
    .token-control input::-webkit-inner-spin-button,
    .token-control input::-webkit-outer-spin-button{ -webkit-appearance:none; margin:0; display:none }
    .token-control input:focus{
      border-color: color-mix(in oklab, var(--pink) 65%, #ffffff00 35%);
      box-shadow: var(--glow);
    }
    .btn{
      --b: var(--pink);
      appearance:none; border:1px solid color-mix(in oklab, var(--b) 35%, #ffffff00 65%);
      color:var(--text); background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
      padding:.55rem .85rem; border-radius: 999px; cursor:pointer; font-weight:600;
      transition: transform .12s ease, box-shadow .15s ease, background .2s ease, border-color .2s ease;
    }
    .btn:hover{ box-shadow: var(--glow); transform: translateY(-1px) }
    .btn:active{ transform: translateY(0) scale(.98) }
    .btn-primary{ background:
        linear-gradient(180deg, color-mix(in oklab, var(--pink) 16%, var(--panel) 84%),
                                 color-mix(in oklab, var(--pink) 26%, var(--panel) 74%));
      border-color: color-mix(in oklab, var(--pink) 55%, #ffffff00 45%); color:white;
    }
    .btn-toggle[aria-pressed="true"]{
      border-color: color-mix(in oklab, var(--pink) 65%, #ffffff00 35%);
      box-shadow: var(--glow);
    }
    .btn.big{ padding:.75rem 1.15rem; font-size:16px }

    /* ===== Hero / Chat Section ===== */
    main{display:block}
    section{scroll-margin-top:72px}

    .hero{
      position:relative; padding: clamp(20px, 3vw, 40px) 0 10px;
    }

    .grid-bg{
      position:absolute; inset:0; pointer-events:none; z-index:-1; opacity:.25;
      background:
        radial-gradient(circle at 50% -60px, color-mix(in oklab, var(--pink) 30%, transparent), transparent 35%),
        repeating-linear-gradient(0deg, #ffffff10 0 1px, transparent 1px 36px),
        repeating-linear-gradient(90deg, #ffffff10 0 1px, transparent 1px 36px);
      mask: radial-gradient(1200px 600px at 50% 0, black 40%, transparent 80%);
    }

    .hero-wrap{
      display:grid; gap: 16px;
      grid-template-columns: 1fr;
      align-items:center;
    }
    .hero-copy{
      display:flex; flex-direction:column; gap:.5rem; padding-top:.25rem;
    }
    .title{
      font-size: clamp(28px, 5.2vw, 56px);
      line-height:1.05;
      font-weight:900;
      letter-spacing:.2px;
    }
    .title .pink{ color:var(--pink); text-shadow: var(--glow) }
    .subtitle{ color:var(--muted); font-size: clamp(14px, 2.2vw, 18px) }
    .subtitle a{
      color: var(--pink-2);
      text-decoration: none;
      border-bottom: 1px solid rgba(255, 134, 195, 0.3);
      transition: all 0.2s ease;
    }
    .subtitle a:hover{
      color: var(--pink);
      border-bottom-color: var(--pink);
      text-shadow: 0 0 8px rgba(255, 46, 136, 0.4);
    }

    .chat-shell{
      border:1px solid color-mix(in oklab, var(--pink) 28%, var(--line) 72%);
      border-radius: var(--radius);
      background:
        linear-gradient(180deg, color-mix(in oklab, var(--panel) 92%, var(--pink) 8%), var(--panel-2)),
        radial-gradient(80% 120% at 10% -10%, rgba(255,46,136,.08), transparent 42%);
      box-shadow:
        0 0 0 1px rgba(255,255,255,.02) inset,
        0 18px 50px rgba(0,0,0,.45),
        0 0 60px -10px rgba(255,46,136,.25);
      overflow:hidden;
      display:flex; flex-direction:column;
      /* FIXED HEIGHT so page layout doesn't shift */
      height: clamp(380px, 54vh, 640px);
      position:relative;
    }
    @supports (height: 54svh){
      .chat-shell{ height: clamp(380px, 54svh, 640px); }
    }

    .chat-header{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; padding: .65rem var(--pad);
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, #151523 0%, #131321 100%);
      flex: 0 0 auto;
    }
    .chat-title{
      display:flex; align-items:center; gap:.6rem; font-weight:700
    }
    .status-dot{
      width:9px; height:9px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #fff, var(--pink));
      box-shadow: 0 0 8px var(--pink), 0 0 14px color-mix(in oklab, var(--pink) 45%, transparent);
    }

    .chat-log{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
      padding: 12px clamp(10px, 2vw, 18px);
      display:flex; flex-direction:column; gap:10px;
      scroll-behavior:smooth;
      background:
        radial-gradient(60% 40% at 60% -10%, rgba(255,46,136,.06), transparent 35%),
        linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0) 16%);
    }
    .msg{
      display:flex; gap:10px; align-items:flex-start; max-width: 820px;
      animation: pop .16s ease-out;
    }
    .msg.me{ margin-left:auto; justify-content:flex-end }
    .bubble{
      border:1px solid #ffffff0f; background: #16162a; padding:10px 12px; border-radius: 14px;
      box-shadow: 0 2px 10px rgba(0,0,0,.25)
    }
    .msg.me .bubble{
      background: linear-gradient(180deg, color-mix(in oklab, var(--pink) 25%, #1a0e18 75%), #1a0e18);
      border-color: color-mix(in oklab, var(--pink) 55%, #ffffff00 45%);
      color:white; text-shadow:0 0 8px rgba(255,46,136,.2)
    }
    /* Emoji avatars (no distortion) */
    .avatar{
      width:28px; height:28px;
      display:flex; align-items:center; justify-content:center;
      font-size:18px; line-height:1;
      border-radius:50%;
      background:#0f0f1b; border:1px solid #2a2a3a;
      box-shadow: 0 0 12px rgba(255,46,136,.22);
      user-select:none;
    }
    .avatar.me{ box-shadow: 0 0 10px rgba(118,118,255,.25); }

    @keyframes pop{ from{transform:scale(.98); opacity:0} to{transform:scale(1); opacity:1}}

    .inputbar{
      display:flex; gap: 8px; align-items:flex-end;
      padding: 10px;
      border-top:1px solid var(--line);
      background: linear-gradient(180deg, #121221 0%, #0f0f1b 100%);
      flex: 0 0 auto;
    }
    .input-wrap{
      position:relative; flex:1; display:flex; align-items:center; background: #0f0f1b;
      border:1px solid #2a2a3a; border-radius: 12px; padding: 6px;
      transition: border-color .15s ease, box-shadow .15s ease;
    }
    .input-wrap:focus-within{
      border-color: color-mix(in oklab, var(--pink) 65%, #ffffff00 35%);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--pink) 26%, transparent);
    }
    .prompt{
      flex:1; min-height: 40px; max-height: 120px; resize:none;
      background:transparent; border:0; color:var(--text);
      padding: 8px 10px; font-size: 15px; line-height:1.35; outline:0;
    }
    .send{
      align-self:stretch; min-width:42px; border-radius: 10px;
      display:inline-flex; align-items:center; justify-content:center;
      background: color-mix(in oklab, var(--pink) 16%, #19192b 84%);
      border:1px solid color-mix(in oklab, var(--pink) 50%, #ffffff00 50%);
      color:white; cursor:pointer; font-weight:700;
      transition: transform .12s ease, box-shadow .2s ease;
    }
    .send:hover{ box-shadow: var(--glow) }
    .send:active{ transform: translateY(1px) }
    .hint{ color:var(--muted); font-size:12px; padding: 0 0px 8px }
    .hint a{
      color: var(--pink-2);
      text-decoration: none;
      border-bottom: 1px solid rgba(255, 134, 195, 0.3);
      transition: all 0.2s ease;
    }
    .hint a:hover{
      color: var(--pink);
      border-bottom-color: var(--pink);
      text-shadow: 0 0 8px rgba(255, 46, 136, 0.4);
    }

    /* ===== Fullscreen Chat ===== */
    body.chat-fullscreen{
      overflow:hidden;
    }
    body.chat-fullscreen .chat-shell{
      position:fixed; inset: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      margin:0; border-radius: 0; z-index:99;
      animation: lift .28s ease;
      height:auto; /* in fullscreen, the 'inset' defines the height */
    }
    @keyframes lift{ from{ transform: translateY(8px); opacity:.6 } to{ transform:none; opacity:1 } }

    /* ===== Loading Overlay (grays out header + chat) ===== */
    .loading-mask{
      position:absolute; inset:0; z-index:50;
      display:flex; align-items:center; justify-content:center;
      background: rgba(10,10,18,.78);
      backdrop-filter: blur(2px) saturate(60%);
    }
    .loading-panel{
      text-align:center; display:flex; flex-direction:column; align-items:center; gap:14px;
      background: linear-gradient(180deg, #141426, #10101c);
      border:1px solid #26263c; border-radius:14px; padding:16px 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,.45), 0 0 24px -8px rgba(255,46,136,.25);
    }
    .loading-title{ font-weight:800; font-size:16px }
    .loading-state{ display:flex; align-items:center; gap:10px }
    .spinner{
      width:22px; height:22px; border-radius:50%;
      border:3px solid rgba(255,255,255,.18); border-top-color: var(--pink);
      animation: spin .9s linear infinite;
    }
    @keyframes spin{ to{ transform: rotate(360deg) } }

    /* ===== Blog Section (LIST ONLY) ===== */
    .section-head{
      display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between;
      gap:12px; padding: 26px 0 8px;
    }
    .section-title{ font-size: clamp(22px, 3.4vw, 34px); font-weight:900 }

    .blog-list{ display:flex; flex-direction:column; gap:12px; padding: 8px 0 36px }

    .post{
      background: linear-gradient(180deg, #131321, #11111c);
      border:1px solid #222238; border-radius: 14px; overflow:clip;
      transition: transform .15s ease, box-shadow .2s ease, border-color .2s ease;
      display:flex; flex-direction:column; min-height: 140px;
    }
    .post:hover{
      transform: translateY(-2px);
      border-color: color-mix(in oklab, var(--pink) 32%, #ffffff00 68%);
      box-shadow: 0 10px 30px rgba(0,0,0,.45), 0 0 24px -8px rgba(255,46,136,.35);
    }
    .post-link{ text-decoration:none; color:inherit }
    .post-body{ padding: 18px 18px 20px; display:flex; flex-direction:column; gap:12px; min-height: 160px }
    .post-title{ font-weight:800; font-size: 20px; line-height:1.2; margin:0 }
    .post-meta{
      margin-top:auto;
      align-self:flex-end;
      text-align:right;
    }
    .post-status{
      display:inline-flex; align-items:center;
      padding:.2rem .75rem; border-radius:999px;
      border:1px solid #2b2b3f;
      background:#16162a;
      font-family:var(--mono);
      font-size:11px; letter-spacing:.35px;
      text-transform:uppercase;
      color:var(--muted);
    }
    .post-status.live{
      border-color: color-mix(in oklab, var(--pink) 55%, #ffffff00 45%);
      color:white;
      background: linear-gradient(180deg, color-mix(in oklab, var(--pink) 18%, #201224 82%), #1a0e1c);
      box-shadow: 0 0 18px rgba(255,46,136,.25);
    }

    /* ===== Footer ===== */
    footer{
      border-top:1px solid var(--line);
      background: #0a0a12;
      color:var(--muted);
      padding: 15px 0 30px;
      font-size: 13px;
    }

    footer a{
      color: var(--pink-2);
      text-decoration: none;
      border-bottom: 1px solid rgba(255, 134, 195, 0.3);
      transition: all 0.2s ease;
    }

    footer a:hover{
      color: var(--pink);
      border-bottom-color: var(--pink);
      text-shadow: 0 0 8px rgba(255, 46, 136, 0.4);
    }

    /* ===== Utilities ===== */
    .hide{ display:none !important }

    /* ===== Responsive tweaks ===== */
    @media (min-width: 900px){
      .hero-wrap{
        grid-template-columns: 1.15fr .95fr;
      }
      .hero{ padding-top: 46px }
    }
  </style>
</head>
<body>
  <script src="gab.js"></script>
  <!-- ====== Main ====== -->
  <main id="top">
    <section id="chat" class="hero" aria-labelledby="hero-title">
      <div class="grid-bg" aria-hidden="true"></div>
      <div class="container hero-wrap">
        <div class="hero-copy">
          <h1 id="hero-title" class="title">
            Say hello to <span class="pink">Gab</span>.
          </h1>
          <p class="subtitle">
            Gab is a 25 million parameter (~100 MiB) small language model that can run locally in your browser. 
            It was built in plain JavaScript as a research project to better understand how LLMs work. 
            Below you'll find a five-part tutorial walking through every step of building the model.
          </p>

          <p class="subtitle">
            Gab comes with a simple <a href="trainer.html">trainer ui</a>, and a <a href="chat.html">chat interface</a> that can test your trained models. There is also a <a href="training_guide.html">training guide</a> to explain the models hyper-paramaters.
          </p>
          <div class="hint" aria-hidden="true">The chat window on this page was pre trained on 
            <a href="https://huggingface.co/datasets/roneneldan/TinyStories">Tiny Stories</a>, 
            <a href="https://huggingface.co/datasets/HuggingFaceFW/fineweb-edu">Fine Web (edu)</a></div>
        </div>

        <!-- Chat Interface -->
        <div class="chat-shell" id="chatShell" aria-label="Chat interface">
          <div id="chatHeader" class="chat-header">
            <div class="chat-title"></div>
            <div class="nav-actions">
              <label class="token-control"><span>Max</span><input type="number" id="maxTokens" value="128" min="1" max="1024" step="1"></label>
              <label class="token-control"><span>Temp</span><input type="number" id="temperature" value="0.7" min="0.1" max="2.0" step="0.1"></label>
              <button id="clearBtn" class="btn" type="button" title="Clear chat">Clear</button>
              <button id="fsBtn" class="btn btn-primary btn-toggle" aria-pressed="false" type="button" title="Enter fullscreen">Fullscreen</button>
            </div>
          </div>

          <div id="chatLog" class="chat-log" role="log" aria-live="polite" aria-relevant="additions">
            <!-- Messages will be injected here -->
          </div>

          <div id="inputBar" class="inputbar">
            <div class="input-wrap" id="inputWrap">
              <textarea id="prompt" class="prompt" placeholder="Let's chat..." rows="1"></textarea>
            </div>
            <button id="sendBtn" class="send" type="button" title="Send (Enter)">
              âž¤
            </button>
          </div>

          <!-- Loading Overlay covers header + chat area -->
          <div id="loadingMask" class="loading-mask" role="dialog" aria-modal="true" aria-labelledby="loadTitle" aria-busy="false">
            <div class="loading-panel">
              <div id="loadTitle" class="loading-title">Model not loaded</div>
              <button id="loadModelBtn" class="btn btn-primary big" type="button">Load model</button>
              <div id="loadingState" class="loading-state hide" aria-live="polite">
                <div class="spinner" aria-hidden="true"></div>
                <div>Loading modelâ€¦</div>
              </div>
            </div>
          </div>

        </div>
      </div>
    </section>

    <!-- ====== Blog Section (LIST ONLY) ====== -->
    <section id="blog" aria-labelledby="blog-title">
      <div class="container">
        <div class="section-head">
          <h2 id="blog-title" class="section-title">Learn how to build a Language Model</h2>
        </div>

        <div id="blogMount" class="blog-list" aria-live="polite" aria-busy="false">
          <!-- Posts rendered here -->
        </div>
      </div>
    </section>
  </main>

  <!-- ====== Footer ====== -->
  <footer>
    <div class="container" style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
      <div>&copy; 2025 <a href="https://gabormakesgames.com/">Gabor Szauer</a></div>
      <div style="display:flex; gap:1rem;">
        <a href="https://github.com/gszauer/Gab">GitHub</a>
        <a href="https://bsky.app/profile/gszauer.bsky.social">bsky</a>
      </div>
    </div>
  </footer>

  <!-- ====== App Script ====== -->
  <script>
    (function(){
      const byId = id => document.getElementById(id);

      const chatShell = byId('chatShell');
      const chatHeader = byId('chatHeader');
      const chatLog = byId('chatLog');
      const inputBar = byId('inputBar');

      const promptInput = byId('prompt');
      const sendBtn = byId('sendBtn');
      const clearBtn = byId('clearBtn');
      const fsBtn = byId('fsBtn');

      const loadingMask = byId('loadingMask');
      const loadModelBtn = byId('loadModelBtn');
      const loadingState = byId('loadingState');

      const blogMount = byId('blogMount');

      // Model state
      let tokenizer = null;
      let model = null;
      let conversationLog = ''; // Raw string chat log following Gab format
      let endTokenId = null;
      let userTokenId = null;
      let assistantTokenId = null;
      let thinkTokenId = null;

      const state = {
        modelLoaded: false,
        fullscreen: false,
        typing: false,
        messages: []
      };

      // ===== Chat Rendering =====
      function renderChat(){
        chatLog.innerHTML = '';
        state.messages.forEach(msg => chatLog.appendChild(messageEl(msg)));
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      function messageEl({role, text}){
        const root = document.createElement('div');
        root.className = 'msg' + (role === 'user' ? ' me' : '');

        const avatar = document.createElement('div');
        avatar.className = 'avatar' + (role === 'user' ? ' me' : '');
        avatar.textContent = role === 'user' ? 'ðŸ‘¤' : 'ðŸ¤–';
        avatar.setAttribute('aria-hidden', 'true');

        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        bubble.innerText = text;

        const wrap = document.createElement('div');
        wrap.style.maxWidth = 'min(740px, 86vw)';
        wrap.append(bubble);

        if(role === 'user'){ root.append(wrap, avatar); }
        else{ root.append(avatar, wrap); }
        return root;
      }

      // ===== Loading Overlay Control =====
      function setLoading(active){
        if(active){
          loadingMask.classList.remove('hide');
          loadingMask.setAttribute('aria-busy','false');
          [chatHeader, chatLog, inputBar].forEach(el=>{
            el.setAttribute('aria-hidden','true');
            el.setAttribute('inert','');
          });
          [fsBtn, clearBtn, sendBtn].forEach(btn => btn.disabled = true);
          promptInput.disabled = true;
          state.modelLoaded = false;
        }else{
          loadingMask.classList.add('hide');
          [chatHeader, chatLog, inputBar].forEach(el=>{
            el.removeAttribute('aria-hidden');
            el.removeAttribute('inert');
          });
          [fsBtn, clearBtn, sendBtn].forEach(btn => btn.disabled = false);
          promptInput.disabled = false;
          state.modelLoaded = true;
          promptInput.focus();
          chatLog.scrollTop = chatLog.scrollHeight;
        }
      }

      // Start in loading state
      setLoading(true);

      // ===== Load Model Files =====
      async function loadModelFiles() {
        loadModelBtn.classList.add('hide');
        loadingState.classList.remove('hide');
        loadingMask.setAttribute('aria-busy','true');

        try {
          // Fetch both files in parallel
          const [modelResponse, tokenizerResponse] = await Promise.all([
            fetch('model.gab'),
            fetch('model.bpe')
          ]);

          if (!modelResponse.ok) throw new Error('Failed to load model.gab');
          if (!tokenizerResponse.ok) throw new Error('Failed to load model.bpe');

          const [modelBuffer, tokenizerBuffer] = await Promise.all([
            modelResponse.arrayBuffer(),
            tokenizerResponse.arrayBuffer()
          ]);

          // Deserialize
          tokenizer = Tokenizer.deserialize(new Uint8Array(tokenizerBuffer));
          model = GabGPT.deserialize(new Uint8Array(modelBuffer));

          // Find special tokens
          const specialTokens = ['<|end|>', '<|user|>', '<|assistant|>', '<|think|>'];
          const tokenIds = [null, null, null, null];
          for (let i = 0; i < specialTokens.length; i++) {
            try {
              const encoded = tokenizer.encode(specialTokens[i]);
              if (encoded.length === 1) {
                tokenIds[i] = encoded[0];
              }
            } catch (e) {
              console.log(specialTokens[i] + ' token not found');
            }
          }
          [endTokenId, userTokenId, assistantTokenId, thinkTokenId] = tokenIds;

          console.log('Model loaded! Vocab size:', model.vocabSize);

          loadingMask.setAttribute('aria-busy','false');
          loadingState.classList.add('hide');
          loadModelBtn.classList.remove('hide');
          setLoading(false);

        } catch (err) {
          console.error('Error loading model:', err);
          loadingMask.setAttribute('aria-busy','false');
          loadingState.classList.add('hide');
          loadModelBtn.classList.remove('hide');
          byId('loadTitle').textContent = 'Error: ' + err.message;
        }
      }

      loadModelBtn.addEventListener('click', loadModelFiles);

      // ===== Fullscreen Toggle =====
      function enterFullscreen(){
        if(state.fullscreen) return;
        state.fullscreen = true;
        document.body.classList.add('chat-fullscreen');
        updateFSBtn();
        if(state.modelLoaded) promptInput.focus();
        setTimeout(()=> chatLog.scrollTop = chatLog.scrollHeight, 60);
      }
      function exitFullscreen(){
        if(!state.fullscreen) return;
        state.fullscreen = false;
        document.body.classList.remove('chat-fullscreen');
        updateFSBtn();
      }
      function toggleFullscreen(){
        state.fullscreen ? exitFullscreen() : enterFullscreen();
      }
      function updateFSBtn(){
        if(state.fullscreen){
          fsBtn.textContent = 'Back';
          fsBtn.title = 'Exit fullscreen';
          fsBtn.setAttribute('aria-pressed','true');
        }else{
          fsBtn.textContent = 'Fullscreen';
          fsBtn.title = 'Enter fullscreen';
          fsBtn.setAttribute('aria-pressed','false');
        }
      }

      // ===== Sampling with Temperature =====
      function sampleWithTemperature(probs, temperature) {
        const logits = [];
        for (let i = 0; i < probs.length; i++) {
          logits.push(Math.log(probs[i] + 1e-10));
        }

        const scaledLogits = [];
        for (let i = 0; i < logits.length; i++) {
          scaledLogits.push(logits[i] / temperature);
        }

        let maxLogit = scaledLogits[0];
        for (let i = 1; i < scaledLogits.length; i++) {
          if (scaledLogits[i] > maxLogit) maxLogit = scaledLogits[i];
        }

        const expLogits = [];
        let sum = 0;
        for (let i = 0; i < scaledLogits.length; i++) {
          const exp = Math.exp(scaledLogits[i] - maxLogit);
          expLogits.push(exp);
          sum += exp;
        }

        const scaledProbs = [];
        for (let i = 0; i < expLogits.length; i++) {
          scaledProbs.push(expLogits[i] / sum);
        }

        const random = Math.random();
        let cumulative = 0;
        for (let i = 0; i < scaledProbs.length; i++) {
          cumulative += scaledProbs[i];
          if (random < cumulative) return i;
        }
        return scaledProbs.length - 1;
      }

      // ===== Chat Behavior =====
      function sendMessage(){
        if(!state.modelLoaded || !model || !tokenizer) return;
        const text = promptInput.value.trim();
        if(!text || state.typing) return;

        state.messages.push({role:'user', text});
        renderChat();
        promptInput.value = '';

        respond(text);
      }

      // Helper: Remove trailing special tokens from string
      function removeTrailingSpecialTokens(str) {
        const tokens = ['<|end|>', '<|user|>', '<|assistant|>', '<|think|>'];
        let changed = true;
        while (changed) {
          changed = false;
          for (const tok of tokens) {
            if (str.endsWith(tok)) {
              str = str.slice(0, -tok.length);
              changed = true;
            }
          }
        }
        return str;
      }

      // Helper: Remove leading think/assistant/end tokens (sanitize)
      function sanitizeLeadingTokens(str) {
        const tokens = ['<|think|>', '<|assistant|>', '<|end|>'];
        let changed = true;
        while (changed) {
          changed = false;
          for (const tok of tokens) {
            if (str.startsWith(tok)) {
              str = str.slice(tok.length);
              changed = true;
            }
          }
        }
        return str;
      }

      // Helper: Strip all special tokens for display
      function stripSpecialTokens(str) {
        return str.replace(/<\|(end|user|assistant|think)\|>/g, '');
      }

      // Prepare chat log for generation per Gab format rules
      function prepareChatLogForGeneration(log, userMessage) {
        // Step 1: Sanitize - remove leading think/assistant/end tokens
        log = sanitizeLeadingTokens(log);

        // Step 2: Ensure user prefix
        if (!log.startsWith('<|user|>')) {
          log = '<|user|>' + log;
        }

        // Step 3: Remove trailing special tokens
        log = removeTrailingSpecialTokens(log);

        // Step 4: Append new user message and suffix (always assistant, no think mode)
        log = log + '<|user|>' + userMessage + '<|assistant|>';

        return log;
      }

      async function respond(userText){
        state.typing = true;
        sendBtn.disabled = true;
        promptInput.disabled = true;

        // Add thinking indicator and get reference to the bubble element
        state.messages.push({role:'assistant', text:'â–Œ'});
        const msgEl = messageEl(state.messages[state.messages.length - 1]);
        const chatLogEl = byId('chatLog');
        chatLogEl.appendChild(msgEl);
        chatLogEl.scrollTop = chatLogEl.scrollHeight;
        const bubbleEl = msgEl.querySelector('.bubble');

        // Prepare the chat log following Gab format rules
        let preparedLog;
        if (conversationLog === '') {
          // First message - just user + assistant suffix
          preparedLog = '<|user|>' + userText + '<|assistant|>';
        } else {
          preparedLog = prepareChatLogForGeneration(conversationLog, userText);
        }

        // Tokenize
        let tokens = tokenizer.encode(preparedLog);

        // Trim from beginning if too long (preserve recent context)
        const maxContext = model.embedding.maxSequenceLength - 100;
        if (tokens.length > maxContext) {
          tokens = tokens.slice(-maxContext);
        }

        const temperature = parseFloat(byId('temperature').value) || 0.7;
        const maxTokens = parseInt(byId('maxTokens').value) || 128;

        let generated = [];
        let responseText = '';

        try {
          for (let i = 0; i < maxTokens; i++) {
            const maxSeqLen = model.embedding.maxSequenceLength;
            let inputTokens = tokens;
            if (tokens.length > maxSeqLen) {
              inputTokens = tokens.slice(-maxSeqLen);
            }

            const batchedInput = [inputTokens];
            const probs = model.forward(batchedInput);
            const lastProbs = probs[0][inputTokens.length - 1];

            const nextToken = sampleWithTemperature(lastProbs, temperature);

            // Check for end token - stop generation
            if (endTokenId !== null && nextToken === endTokenId) {
              break;
            }

            tokens.push(nextToken);
            generated.push(nextToken);

            // Decode and update display (strip special tokens for display)
            responseText = stripSpecialTokens(tokenizer.decode(generated));

            // Update just the bubble text (no re-render)
            state.messages[state.messages.length - 1].text = responseText + 'â–Œ';
            bubbleEl.textContent = responseText + 'â–Œ';
            chatLogEl.scrollTop = chatLogEl.scrollHeight;

            // Yield to UI
            await new Promise(resolve => setTimeout(resolve, 0));
          }

          // Final update (remove cursor)
          const finalText = responseText || '(empty response)';
          state.messages[state.messages.length - 1].text = finalText;
          bubbleEl.textContent = finalText;

          // Post-generation: update chat log
          // Format: previous log + user message + assistant response + <|end|>
          // Then append <|user|> to prepare for next message
          if (conversationLog === '') {
            conversationLog = '<|user|>' + userText + '<|assistant|>' + tokenizer.decode(generated) + '<|end|><|user|>';
          } else {
            conversationLog = removeTrailingSpecialTokens(conversationLog) + '<|user|>' + userText + '<|assistant|>' + tokenizer.decode(generated) + '<|end|><|user|>';
          }

        } catch (err) {
          console.error('Generation error:', err);
          state.messages[state.messages.length - 1].text = 'Error: ' + err.message;
          bubbleEl.textContent = 'Error: ' + err.message;
        }

        state.typing = false;
        sendBtn.disabled = false;
        promptInput.disabled = false;
        promptInput.focus();
      }

      // ===== Event wiring =====
      sendBtn.addEventListener('click', sendMessage);
      promptInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' && !e.shiftKey){
          e.preventDefault();
          sendMessage();
        }
      });

      fsBtn.addEventListener('click', toggleFullscreen);

      clearBtn.addEventListener('click', ()=>{
        if(state.typing) return;
        state.messages = [];
        conversationLog = '';
        renderChat();
      });

      // ===== Blog Data =====
      const POSTS = [
        {title:"Part 1 / 4: Learning", eta:"Read now", blurb:"Learn how to build a trainable neural network from scratch in plain JavaScript, starting with a single neuron, adding dense and activation layers, and training it to solve problems like XOR using backpropagation and gradient descent.", url:'blog_learning.html'},
        {title:"Part 2 / 4: Tokenization", eta:"Read now", blurb:"Language models don't see text the way we do. They see sequences of tokens,numerical representations of characters and text. This tutorial teaches you how to to build a Byte Pair Encoding (BPE) Tokenizer from scratch", url:'blog_tokenizer.html'},
        {title:"Part 3 / 4: Sequences", eta:"Read now", blurb:"Dense networks see inputs as isolated snapshots, they have no concept of sequence. This tutorial builds a recurrent neural network that memory across tokens, ChatRNN. It is language model that learns to predict the next word.", url:'blog_recurrent.html'},
        {title:"Part 4 / 4: Attention", eta:"Read now", blurb:"Build a GPT-2 style transformer from scratch. Learn about positional embeddings, layer normalization, self-attention mechanisms, and how to assemble complete transformer blocks.", url:'blog_attention.html'},
        {title:"Part 5 / 4: Training", eta:"Read now", blurb:"Learn how to implement batch training, pre-training, supervised fine-tuning (SFT), and optimization tricks like Adam to train a chatbot from scratch.", url:'blog_training.html'},
        //{title:"Too Long; Didn't Read", eta:"Coming soon", blurb:"Description"},
      ];

      // ===== Blog Rendering =====
      function renderPosts(posts){
        blogMount.setAttribute('aria-busy','true');
        blogMount.innerHTML = '';

        posts.forEach(p => {
          const isLink = Boolean(p.url);
          const card = document.createElement(isLink ? 'a' : 'article');
          card.className = 'post' + (isLink ? ' post-link' : '');
          if(isLink){
            card.href = p.url;
            card.setAttribute('aria-label', p.title);
          }
          card.innerHTML = `
            <div class="post-body">
              <div>
                <h3 class="post-title">${escapeHTML(p.title)}</h3>
                <p style="margin:.45rem 0 .1rem; color:#d9d9ec">${escapeHTML(p.blurb)}</p>
              </div>
              <div class="post-meta">
                <span class="post-status${isLink ? ' live' : ''}">${escapeHTML(p.eta)}</span>
              </div>
            </div>
          `;
          blogMount.appendChild(card);
        });
        blogMount.setAttribute('aria-busy','false');
      }

      function escapeHTML(s){
        return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
      }

      // ===== Init =====
      renderChat();
      renderPosts(POSTS);

      // Mobile: auto-grow textarea
      const autoGrow = () => {
        promptInput.style.height = 'auto';
        promptInput.style.height = Math.min(promptInput.scrollHeight, 120) + 'px';
      };
      promptInput.addEventListener('input', autoGrow);
      autoGrow();

      updateFSBtn();
    })();
  </script>
</body>
</html>
